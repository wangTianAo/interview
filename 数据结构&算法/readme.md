# 数据结构&算法
摘自 https://blog.csdn.net/sup_heaven/article/details/39313731
## BST二叉搜索树
* 所有非叶子结点至多拥有两个儿子（Left和Right）
* 所有结点存储一个关键字
* 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树
![](https://p-blog.csdn.net/images/p_blog_csdn_net/manesking/31.JPG) 

## AVL平衡二叉搜索树
平衡二叉树或为空树,或为如下性质的二叉排序树:
* 左右子树深度之差的绝对值不超过1
* 左右子树仍然为平衡二叉树
平衡因子BF=左子树深度－右子树深度.平衡二叉树每个结点的平衡因子只能是1，0，-1。若其绝对值超过1，则该二叉排序树就是不平衡的。

## RBT 红黑树
搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树<br>
一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：<br>
* 每个结点要么是红的，要么是黑的
* 根结点是黑的
* 每个叶结点，即空结点（NIL）是黑的
* 如果一个结点是红的，那么它的俩个儿子都是黑的
* 对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点

## B树和B+树的区别
https://blog.csdn.net/login_sonata/article/details/75268075
### B树优点
* 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。
### B+树优点
* 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
* 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。

## 排序算法
| 排序算法  | 平均时间复杂度 | 最差时间复杂度  | 	空间复杂度	 | 数据对象稳定性 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
|冒泡排序	|O(n2)	|O(n2)	|O(1)	|稳定|
|选择排序	|O(n2)	|O(n2)	|O(1)	|数组不稳定、链表稳定|
|插入排序	|O(n2)	|O(n2)	|O(1)	|稳定|
|快速排序	|O(n*log2n) |O(n2)|O(log2n)	|不稳定|
| 堆排序	 | O(n*log2n)	|O(n*log2n)|O(1)	|不稳定|
|归并排序|	O(n*log2n)	|O(n*log2n)|	O(n)|	稳定|
|希尔排序	|O(n*log2n)|	O(n2)	|O(1)|	不稳定|
|计数排序	|O(n+m)	|O(n+m)	|O(n+m)	|稳定|
|桶排序	|O(n)	|O(n)	|O(m)	|稳定|
|基数排序	|O(k*n)	|O(n2)|	|	稳定|

## 找无序数组中第K大的数
可以用容量为 K 的最小堆来存储最大的 K 个数。最小堆的堆顶元素就是最大 K 个数中最小的一个。每次新考虑一个数 X，如果 X 比堆顶的元素Y 小，则不需要改变原来的堆，因为这个元素比最大的 K 个数小。如果 X 比堆顶元素大，那么用 X 替换堆顶的元素 Y。在 X 替换堆顶元素 Y 之后，X 可能破坏最小堆的结构（每个结点都比它的父亲结点大），需要更新堆来维持堆的性质。更新过程花费的时间复杂度为 O（log2K）。

因此，算法只需要扫描所有的数据一次，时间复杂度为 O（N * log2K）。
