# Unity
摘自 https://gameinstitute.qq.com/community/detail/108207<br>
https://blog.csdn.net/qq_26270779/article/details/53609069<br>
https://blog.csdn.net/qq_40930606/article/details/80502289<br>

## 什么是协同程序？
* 协程称为协同程序,即在主线程运行的同时开启另一段逻辑，来协助当前程序的执行，StartCoroutine是开启协程,StopCoroutine是关闭协程，协程的返回值是 IEnumerator类型,而在协程内部必须有yield return **,IEnumerator用来记录执到yield return的位置,每次执行协程时均是从当前位置向后执行,而不是从协程的最开始位置执行,除非只有一个yield return;在一个主程序中可以开启多个协程。

## Unity3d中的碰撞器和触发器的区别？
* 碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。
* 当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；
* 当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。
* 如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器

## 物体发生碰撞的必要条件
* 两个物体都必须带有碰撞器Collider，其中一个物体还必须带有Rigidbody刚体

## 请简述ArrayList和List的主要区别
* ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理）有装箱拆箱的操作
* List是泛型，可以指定特定的类型,避免过多的装箱拆箱操作,增加对内存的消耗

## 请简述GC（垃圾回收）产生的原因，并描述如何避免？
https://gameinstitute.qq.com/community/detail/125200<br>
* GC回收堆上的内存
* 减少new产生对象的次数
* 使用公用的对象（静态成员）
* 将String换为StringBuilder
### Unity内存管理机制简介
Unity主要采用自动内存管理的机制，开发时在代码中不需要详细地告诉unity如何进行内存管理，unity内部自身会进行内存管理，其自动管理主要可以理解为以下几个部分：
* unity内部会有两个内存管理池：堆内存和堆栈内存。堆栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。
* unity中的变量只会在堆栈或者堆内存上进行内存分配
* 只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态
* 一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中再次被使用，这样的操作就是内存回收。处于堆栈上的内存回收速度极其快速，处于堆上的内存并不是及时回收的，因此其对应的内存依然会被标记为使用状态
* 垃圾回收主要是指堆上的内存分配和回收，unity中会定时堆堆内存进行GC操作

## 简述四元数Quaternion的作用，四元数对欧拉角的优点？
都是用于旋转
* 能进行增量旋转
* 避免万向锁
* 给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式）

## 如何安全的在不同工程间安全地迁移asset数据？三种方法
* 将Assets和Library一起迁移
* 导出包package
* 用unity自带的assets Server功能

## Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法
Awake——>OnEnable–>Start——>FixedUpdate——>Update——>LateUpdate——>OnGUI——>OnDisable——>OnDestroy
* Awake：用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次.
* Start：仅在Update函数第一次被调用前调用。Start在behaviour的生命周期中只被调用一次。它和Awake的不同是Start只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。
* FixedUpdate：固定帧更新，在Unity导航菜单栏中，点击“Edit”-->“Project Setting”-->“Time”菜单项后，右侧的Inspector视图将弹出时间管理器，其中“Fixed Timestep”选项用于设置FixedUpdate()的更新频率，更新频率默认为0.02s
* Update：正常帧更新，用于更新逻辑。每一帧都执行，处理Rigidbody时，需要用FixedUpdate代替Update。
* LateUpdate：在所有Update函数调用后被调用，和fixedupdate一样都是每一帧都被调用执行，这可用于调整脚本执行顺序。
* OnGUI：在渲染和处理GUI事件时调用。
* OnDisable：当物体被销毁时 OnDisable将被调用，并且可用于任意清理代码。
* OnDestroy：当MonoBehaviour将被销毁时，这个函数被调用。OnDestroy只会在预先已经被激活的游戏物体上被调用。注意：OnDestroy也不能用于协同程序。


## MeshRender中material和sharedmaterial的区别？
修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。<br>
不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使用material替代。<br>

## Unity提供了几种光源，分别是什么
* 平行光：Directional Light
* 点光源：Point Light
* 聚光灯：Spot Light
* 区域光源：Area Light

## 简述一下对象池，你觉得在FPS里哪些东西适合使用对象池
对象池就存放需要被反复调用资源的一个空间，当一个对象回大量生成的时候如果每次都销毁创建会很费时间，通过对象池把暂时不用的对象放到一个池中（也就是一个集合），当下次要重新生成这个对象的时候先去池中查找一下是否有可用的对象，如果有的话就直接拿出来使用，不需要再创建，如果池中没有可用的对象，才需要重新创建，利用空间换时间来达到游戏的高速运行效果，在FPS游戏中要常被大量复制的对象包括子弹，敌人，粒子等

## CharacterController和Rigidbody的区别
Rigidbody具有完全真实物理的特性，Unity中物理系统最基本的一个组件，包含了常用的物理特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的，是Unity为了使开发者能方便的开发第一人称视角的游戏而封装的一个组件

## 简述prefab的用处
* 在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，以便于以后的修改，同事prefab打包的内容简化了导出的操作，便于团队的交流。

## Update、FixedUpdate 和 LateUpdate 的区别
* Update在每一帧被调用，30fps就30次
* FixedUpdate在固定帧调用，不受游戏帧率的影响，可以设置比如0.02s一次，FixedUpdate的时间间隔可以在项目设置中更改，Edit->ProjectSetting->time  找到Fixedtimestep。就可以修改了
* LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的Update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。

### Update和FixedUpdate的区别：
* update跟当前平台的帧数有关，而FixedUpdate是真实时间，所以处理物理逻辑的时候要把代码放在FixedUpdate而不是Update.

## 请简述sealed关键字用在类声明时与函数声明时的作用。
类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。

## 请简述private，public，protected，internal的区别
* public：对任何类和成员都公开，无限制访问
* private：仅对该类公开
* protected：对该类和其派生类公开
* internal：只能在包含该类的程序集中访问该类

## 什么叫做链条关节
Hinge Joint，可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力

## 使用Unity3d实现2d游戏，有几种方式
* 使用本身的GUI，在Unity4.6以后出现的UGUI
* 把摄像机的Projection(投影)值调为Orthographic(正交投影)，不考虑z轴
* 使用2d插件，如：2DToolKit，和NGUI

## 在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数
三个阶段，1.OnCollisionEnter 2.OnCollisionStay 3.OnCollisionExit

## Unity3d的物理引擎中，有几种施加力的方式，分别描述出来
rigidbody.AddForce，rigidbody.AddForceAtPosition

## GPU的工作原理
简而言之，GPU的图形（处理）流水线完成如下的工作：（并不一定是按照如下顺序）
* 顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Vertex Shader（定点着色器）完成。
* 光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。
* 纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping unit）即是用来完成此项工作。
* 像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。
* 最终输出：由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区。
* 总结：GPU的工作通俗的来说就是完成3D图形的生成，将图形映射到相应的像素点上，对每个像素进行计算确定最终颜色并完成输出。

## 什么是渲染管道？
* 是指在显示器上为了显示出图像而经过的一系列必要操作。 渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。
* 主要步骤有：本地坐标->视图坐标->背面裁剪->光照->裁剪->投影->视图变换->光栅化。

## 如何优化内存？
* 压缩自带类库；
* 将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；
* 释放AssetBundle占用的资源；
* 降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；
* 使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。

## 动态加载资源的方式?
* Resources.Load();
* AssetBundle

## 在场景中放置多个Camera并同时处于活动状态会发生什么？
游戏界面可以看到很多摄像机的混合

## 如何销毁一个UnityEngine.Object及其子类？
使用Destroy()方法;

## 请描述游戏动画有哪几种，以及其原理？
主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。 
* 关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画；
* 骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观
* 单一网格模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实

## 请描述为什么Unity3d中会发生在组件上出现数据丢失的情况
一般是组件上绑定的物体对象被删除了

## LOD是什么，优缺点是什么？
LOD(Level of detail)多层次细节，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。缺点是增加了内存。

## Vertex Shader是什么，怎么计算？
顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。<br>
Vertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。<br>

## MipMap是什么，作用？
MipMapping：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap

## .Net与Mono的关系？
mono是.net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。.net只能在windows下运行，mono可以实现跨平台编译运行，可以运行于linux，Unix，Mac OS等。

## Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？
仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用。如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象

## Unity3D的协程和C#线程之间的区别是什么？
* 多线程程序同时运行多个线程 ，而在任一指定时刻只有一个协程在运行，并且这个正在运行的协同程序只在必要时才被挂起。
* 除主线程之外的线程无法访问Unity3D的对象、组件、方法。
* Unity3d没有多线程的概念，不过unity也给我们提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 StartCoroutine为什么叫协同程序呢，所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。

## u3d中用于记录节点空间几何信息的组件名称，及其父类名称
Transform 父类是 Component

## 向量的点乘、叉乘以及归一化的意义？
* 点乘描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影
* 叉乘得到的向量垂直于原来的两个向量
* 标准化向量：用在只关系方向，不关心大小的时候

## 为何大家都在移动设备上寻求U3D原生GUI的替代方案
不美观，OnGUI很耗费时间，使用不方便

## 请简述如何在不同分辨率下保持UI的一致性
NGUI很好的解决了这一点，屏幕分辨率的自适应性，原理就是计算出屏幕的宽高比跟原来的预设的屏幕分辨率求出一个对比值，然后修改摄像机的size

## 请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？
当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。

## 什么叫动态合批？跟静态合批有什么区别？
* 如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。
* 区别：动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。静态批处理：自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了。

## 简述StringBuilder和String的区别？
* String是字符串常量。
* StringBuffer是字符串变量 ，线程安全。
* StringBuilder是字符串变量，线程不安全。
* String类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，所以效率很低，建议在不断更改String对象的地方不要使用String类型。
* StringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能。这一点我们平时使用中也许都知道，连接操作频繁的时候，使用StringBuilder对象。

## 什么是LightMap？
LightMap:就是指在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上，最后又通过引擎贴到场景上，这样就使物体有了光照的感觉。

## Unity3D Shader分哪几种，有什么区别？
* 表面着色器的抽象层次比较高，它可以轻松地以简洁方式实现复杂着色。表面着色器可同时在前向渲染及延迟渲染模式下正常工作。
* 顶点片段着色器可以非常灵活地实现需要的效果，但是需要编写更多的代码，并且很难与Unity的渲染管线完美集成。
* 固定功能管线着色器可以作为前两种着色器的备用选择，当硬件无法运行那些酷炫Shader的时，还可以通过固定功能管线着色器来绘制出一些基本的内容。

## 值类型和引用类型有何区别？
* 值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。
* 值类型存取速度快，引用类型存取速度慢。
* 值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用
* 值类型继承自System.ValueType，引用类型继承自System.Object
* 栈的内存分配是自动释放；而堆在.NET中会有GC来释放
* 值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。
* 值类型变量直接把变量的值保存在堆栈中，引用类型的变量把实际数据的地址保存在堆栈中。

## 结构体和类有何区别？
结构体是一种值类型，而类是引用类型。就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作。'


